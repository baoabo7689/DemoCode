const MemoryCache = require("@nex3/memory-cache");
const { MarketRepository, GameMarketRepository, ChipRepository, GameConfigsRepository } = require("../models");
const Util = require("../util");
const Translation = require("@nex3/translation");
const util = require("../util");
const R = require("ramda");

class Market {
  static instance;

  /**
   * @returns {Market}
   */
  static getInstance(cacheTimeout) {
    if (!Market.instance) {
      Market.instance = new Market({ cacheTimeout });
    }

    return Market.instance;
  }

  static init(cacheTimeout) {
    Market.instance = new Market({ cacheTimeout });
  }

  constructor({ cacheTimeout } = { cacheTimeout: 60000 }) {
    this.cacheOptions = { timeout: cacheTimeout };
  }

  async getGameSettings() {
    const chips = await this.getAllChips();
    const games = await this.getGameSettingsAllMarket();
    const marketConfigs = this.transformToGameConfigs(games);
    const supportedGameByCurrency = this.transformToGameAndCurrency(games);

    return {
      chips,
      marketConfigs,
      supportedGameByCurrency,
    };
  }

  transformToGameAndCurrency(games) {
    const groupByGame = R.groupBy((game) => game.gameId);

    return R.mergeAll(
      Object.values(groupByGame(games)).map((games) => {
        const currencies = games.flatMap(R.prop("currencies")).filter(R.identity);
        const firstGame = games && games.length && games[0];

        if (firstGame) {
          return {
            [firstGame.gameId]: currencies,
          };
        }
      })
    );
  }

  transformToGameConfigs(games) {
    const groupByMarket = R.groupBy((game) => game.marketName);
    const byGameId = (a, b) => a.gameId - b.gameId;

    const transformGameSetting = (game) => ({
      gameId: game.gameId,
      gameName: game.gameName,
      iconSize: game.iconSize,
      sortOrder: game.sortOrder,
      chips: game.chips,
    });

    const transformMarketSettings = (games) => {
      const settings = games.map(transformGameSetting).sort(byGameId);
      const firstGame = games && games.length && games[0];

      if (firstGame) {
        return {
          currencies: firstGame.currencies,
          defaultChip: firstGame.defaultChip,
          marketName: firstGame.marketName,
          rate: firstGame.rate,
          settings,
        };
      }
    };

    const gamesByMarket = groupByMarket(games.filter(R.prop("marketName")));

    return Object.values(gamesByMarket).map(transformMarketSettings).filter(R.identity);
  }

  async getGameSettingsAllMarket() {
    const isEnabled = R.propEq("enabled", true);
    const markets = await this.getAllMarket();
    const gameMarkets = await this.getAllGameMarket();
    const activeMarkets = markets.filter(isEnabled);

    const games = await Promise.all(
      gameMarkets.map(async (gameMarket) => {
        const additionProps = R.omit(["__v", "time", "_id", "markets"], gameMarket);
        const activeGameMarkets = gameMarket.markets.filter(isEnabled);

        return await Promise.all(activeGameMarkets.map((market) => this.getMarketConfigsInGame(activeMarkets, market, additionProps)));
      })
    );

    return games.flat();
  }

  async getMarketConfigsInGame(markets, marketInGame, additionProps = {}) {
    const byId = (market) => market._id.toString() === marketInGame.marketId;
    const market = markets.find(byId);
    const mergedMarket = R.mergeLeft(marketInGame, market);

    mergedMarket.chips = await this.getChipsByIds(marketInGame.enabledChips);
    mergedMarket.defaultChip = await this.getChipValueById(marketInGame.defaultChipId);

    return R.mergeLeft(R.omit(["__v", "_id", "time", "marketId", "enabledChips", "defaultChipId"], mergedMarket), additionProps);
  }

  /**
   * @param {number} gameId
   * @param {string} currency
   * @param {string} language
   */
  async getGameMarketConfig(gameId, currency, language = "en") {
    const translation = Translation.getInstance(language);
    const gameMarket = await this.getGameMarketById(gameId);

    const market = await this.getMarketByCurrency(currency);
    const gameMarketConfig = await this.getGameMarketConfigByIdAndCurrency(gameId, currency);

    if (gameMarketConfig) {
      const chips = await this.getChipsByIds(gameMarketConfig?.enabledChips ?? []);
      const choiceToProperty = (choice) => ({ [choice.name]: choice.maxBet });
      const maxBetChoices = R.mergeAll(gameMarketConfig?.maxBetChoices?.map(choiceToProperty));
      const gameConfigOriginal = await MemoryCache.getValue(
        Util.cacheKeys.gameConfigs(gameId),
        () => GameConfigsRepository.getByName(gameMarket.gameName),
        this.cacheOptions
      );
      const gameConfigOriginalNormalized = Util.normalizeGameConfigs(gameConfigOriginal);

      const disabledMessage =
        !market.enabled || !gameMarketConfig.enabled
          ? translation.t(translation.keys.marketIsDisabled)
          : gameConfigOriginalNormalized.disabledMessage;

      const newConfig = {
        maxBetChoices,
        chips: chips.map(util.normalizeChip),
        enabled: market.enabled && gameMarketConfig.enabled,
        disabledMessage,
      };

      const configs = Object.assign({}, gameConfigOriginalNormalized, gameMarketConfig, newConfig);

      return R.dissoc("enabledChips", configs);
    }
  }

  async getChipsByIds(ids) {
    const allChips = await this.getAllChips();
    const chips = ids?.map((id) => allChips.find((chip) => chip?._id?.toString() === id)).filter(R.identity) ?? allChips;

    return chips.length ? chips : allChips;
  }

  async getChipValueById(id) {
    const allChips = await this.getAllChips();
    const byId = (id) => R.propEq("_id", id);
    const chip = allChips.find(byId(id));

    return chip?.value ?? 0;
  }

  async getGameMarketConfigByIdAndCurrency(gameId, currency) {
    const gameMarket = await this.getGameMarketById(gameId);
    const market = await this.getMarketByCurrency(currency);

    return gameMarket?.markets.find(R.propEq("marketId", market?._id?.toString()));
  }

  async getMarketByCurrency(currency) {
    const allMarkets = await this.getAllMarket();

    return allMarkets.find((market) => market.currencies.includes(currency));
  }

  async getBaseMarket() {
    const allMarkets = await this.getAllMarket();

    return allMarkets.find((market) => market.isBase);
  }

  getAllGameMarket() {
    return MemoryCache.getValue(Util.cacheKeys.allGameMarkets, GameMarketRepository.getAll, this.cacheOptions);
  }

  getGameMarketById(gameId) {
    return MemoryCache.getValue(Util.cacheKeys.gameMarket(gameId), R.always(GameMarketRepository.getByGameId(gameId)), this.cacheOptions);
  }

  getAllMarket() {
    return MemoryCache.getValue(Util.cacheKeys.allMarkets, MarketRepository.getAll, this.cacheOptions);
  }

  getAllChips() {
    return MemoryCache.getValue(Util.cacheKeys.allChips, ChipRepository.getAll, this.cacheOptions);
  }
}

module.exports = Market;
module.exports.default = Market;
